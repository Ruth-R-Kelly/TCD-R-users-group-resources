zp1 <- ggplot(All_mods, aes(colour = Species, shape = Species))
zp2 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/4), lty = 2) +
geom_pointrange(aes(x = modelName, y = Coefficient,
ymin = Confint_L,
ymax = Confint_U),show.legend=T,
lwd = 0.5, position = position_dodge(width = 2/3)) +
ggtitle("Visiting pollinator abundance") +
theme(plot.title = element_text(hjust = 0.5)) +
coord_flip() + theme_bw() +
theme(axis.title.y=element_blank()) +
theme(plot.title = element_text(face="bold", size=15, hjust = 0.5)) +
theme(legend.text = element_text(face = "italic", size = 8))  +
scale_colour_brewer(palette = "Set1") +
theme(axis.text.x = element_text(size = 8)) +
theme(axis.text.y = element_text(size = 8)) +
theme(axis.title.x = element_text(size = 8)) +
theme(plot.title = element_text(size = 11)) +
guides(colour = guide_legend(title = NULL))  +
guides(shape = guide_legend(title = NULL))
print(zp2)
library("ggplot")
library("ggplot2")
zp1 <- ggplot(All_mods, aes(colour = Species, shape = Species))
zp2 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/4), lty = 2) +
geom_pointrange(aes(x = modelName, y = Coefficient,
ymin = Confint_L,
ymax = Confint_U),show.legend=T,
lwd = 0.5, position = position_dodge(width = 2/3)) +
ggtitle("Visiting pollinator abundance") +
theme(plot.title = element_text(hjust = 0.5)) +
coord_flip() + theme_bw() +
theme(axis.title.y=element_blank()) +
theme(plot.title = element_text(face="bold", size=15, hjust = 0.5)) +
theme(legend.text = element_text(face = "italic", size = 8))  +
scale_colour_brewer(palette = "Set1") +
theme(axis.text.x = element_text(size = 8)) +
theme(axis.text.y = element_text(size = 8)) +
theme(axis.title.x = element_text(size = 8)) +
theme(plot.title = element_text(size = 11)) +
guides(colour = guide_legend(title = NULL))  +
guides(shape = guide_legend(title = NULL))
print(zp2)
All_mods <- read.csv("pollinator_mods.csv")
summary(All_mods)
zp1 <- ggplot(All_mods, aes(colour = Species, shape = Species))
zp2 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/4), lty = 2) +
geom_pointrange(aes(x = modelName, y = Coefficient,
ymin = Confint_L,
ymax = Confint_U),show.legend=T,
lwd = 0.5, position = position_dodge(width = 2/3)) +
ggtitle("Visiting pollinator abundance") +
theme(plot.title = element_text(hjust = 0.5)) +
coord_flip() + theme_bw() +
theme(axis.title.y=element_blank()) +
theme(plot.title = element_text(face="bold", size=15, hjust = 0.5)) +
theme(legend.text = element_text(face = "italic", size = 8))  +
scale_colour_brewer(palette = "Set1") +
theme(axis.text.x = element_text(size = 8)) +
theme(axis.text.y = element_text(size = 8)) +
theme(axis.title.x = element_text(size = 8)) +
theme(plot.title = element_text(size = 11)) +
guides(colour = guide_legend(title = NULL))  +
guides(shape = guide_legend(title = NULL))
print(zp2)
Cam <- read.csv("Central_america.csv")
summary(Cam)
### First set up your plot by choosing which variables to show on the x and y axes
### and add geom_bar() which draws bars
p1 <- ggplot(Cam, aes(x = country, y = Density)) +
geom_bar(stat = "identity", fill = "light blue", colour = "black")
setwd("C:/R/TCD-R-users-group-resources/ggplot2rk")
Cam <- read.csv("Central_america.csv")
summary(Cam)
### First set up your plot by choosing which variables to show on the x and y axes
### and add geom_bar() which draws bars
p1 <- ggplot(Cam, aes(x = country, y = Density)) +
geom_bar(stat = "identity", fill = "light blue", colour = "black")
p1
pdf("test1.pdf")
p1 <- ggplot(Cam, aes(x = country, y = Density)) +
geom_bar(stat = "identity", fill = "light blue", colour = "black")
p1
dev.off()
?pdf
?eps
?merge
knitr::opts_chunk$set(echo = TRUE)
library("plyr")
library("dplyr")
library("reshape2")
data(iris)
summary(iris)
## Iris is a dataframe with information about flowering plants.
## Suppose for example that we only want data for the plants of the species "versicolor"
## we would write
versicolor_data <- filter(iris, Species == "versicolor")
summary(versicolor_data)
### Now we have only the data for this species.  If we wanted two species we would use
### the "|" symbol which means OR
set_ver_data <- filter(iris, Species == "versicolor" |
Species == "setosa")
summary(set_ver_data)
## Or if we have a list of species which we want to keep then we use the operator "%in%"
## which means "is in list"
l1 <- c("versicolor", "setosa")
set_ver_data2 <- filter(iris, Species %in% l1)
summary(set_ver_data2)
## After removing factor levels, it is usually a good idea to use the function
## droplevels()  so that they no longer appear in the summary/plots etc.. This saves
## confusion later
## eg.
set_ver_data <- droplevels(set_ver_data)
summary(set_ver_data)
#### filter can also be used to choose rows based on continuous variables.
## eg. To get plants with a petal length > 3 use
long_leaves <- filter(iris, Petal.Length > 3)
summary(long_leaves)
### when working with numeric variables we can also use the operators "&"
large_leaves <- filter(iris, Petal.Length > 5.7 & Petal.Width > 2)
summary(large_leaves)
### Warning: for some reason the operator "!=" does not work as expected with filter..
### Again using iris
data(iris)
names(iris)
##  If I only wanted the Species names and information about petals I could use select
## e.g.
Petals <- select(iris, Species, Petal.Length, Petal.Width)
head(Petals)
## Note this also changes the column order.
## There are lots of options for selecting columns this way..
## Here are a few from the help menu
## eg.
head(select(iris, ends_with("Width")))
head(select(iris, contains("etal")))
vars <- c("Petal.Length", "Petal.Width")
head(select(iris, one_of(vars)))
data(iris)
names(iris)
head(arrange(iris, Petal.Length))
### Here I'm creating an example dataframe with information about animals in it.
### Each row contains information relating to each animal species
creatures <- data.frame(animal = c("Unicorn", "Antelope", "Centaur", "Aarkvark","Trout"),
real = c("no","yes", "no", "yes", "maybe"),
bodymass = c(1300,1200, 1500, 500, 300),
intellect = c(120, 80, 100,30,10),
speed = c(300, 200, 300, 20, 50))
creatures
stacked_attributes <- melt(creatures, id = c("animal", "real"), value.name = "Value")
stacked_attributes
## For example we can change the melt example above back to it's original form using..
dcast(stacked_attributes, formula = animal + real ~ variable, value.var = "Value")
### In this example we've recieved some information about where our animals where measured, in the form of latitude and longitude coordinates.
###
## This next code creates the example dataset
lat_long <- data.frame(Animal = c( "Antelope", "Centaur","Unicorn", "Aarkvark","Trout",                 "Salmon"),
latitude = c(45,53,-60, 12, 120, 43),
longitude = c(60,40, 33, -34, 86, 58))
names(lat_long)
names(creatures)
### In this example I want to add the information of latitude and longitude to the ###dataframe 'creatures' so that it is added to the correct animals.  This is called a ###merge, and we need to specify the columns in the dataset, which should be used as ###reference.  Here, it is the column 'animal' in the dataset 'creatures' and the column ###'Animal' in the dataset 'lat_long'.
# eg.
merge(x = creatures, y = lat_long, by.x = "animal", by.y = "Animal", all = TRUE)
##  Note the argument all = TRUE controls whether all information from both datasets is ## retained.  If, for example, we only wanted the latitude and longitude data for
## animals which are already in the 'creatures' dataset we would use all.x = TRUE
## i.e.
merge(x = creatures, y = lat_long, by.x = "animal", by.y = "Animal", all.x = TRUE)
## again using iris
## here I summarise by species.
Average_petal_length <- summarise(group_by(iris,Species),
mean(Petal.Length))
Average_petal_length
## If you want to summarise more variables just add these at the end of the function..
## e.g.
summarise(group_by(iris,Species),
mean(Petal.Length),
sd(Petal.Length),
mean(Petal.Width),
sd(Petal.Width))
## You can also add levels to the grouping factor.
## For example, suppose we add a column to our data for site.
iris$site <- rep(c("Dublin","Cork", "Galway"), by = 50)
## now if we want to summarise per species within site, then we do this in the
## 'group_by' part of the summarise function
summarise(group_by(iris,site, Species),
mean(Petal.Length),
sd(Petal.Length),
mean(Petal.Width),
sd(Petal.Width),
ratio = mean(Petal.Length)/mean(Petal.Width) )
# example data:
# I randomly generate a dataset as the example data
# in this data, there are 5 sampling site, in each site there are three blocks, and one #block have 6 plot with 4 subplots embedded in it
# taxon is the species
# biomass is the biomass for each species
# time is the sampling time
mydata<-expand.grid(
site_code = paste(letters[1:5],letters[6:10],sep=''),
block     = 1:3,
plot      = 1:6,
subplot   = 1:4,
taxon     = paste('species.',1:20,sep=''),
time      = 0:12
)
mydata<-transform(mydata,biomass=rexp(nrow(mydata)))
# let's see how we can use ddply to calculate the temporval variability of the total #biomass in each subplot
#method 1
# we can use twice ddply - without self-defined function
#sum the total mass for each subplot in each sampling time
sum.biomass.each.time<-ddply(
mydata,
~ site_code + block + plot + subplot + time,
summarize,
total.mass = sum(biomass)
)
head(sum.biomass.each.time)
# then we calculate the temporal variability using sum.biomass.each.time
tv.total.mass.for.subplots.1<-ddply(
sum.biomass.each.time,
~ site_code + block + plot + subplot,
summarize,
temporal.variability = sd(total.mass)/mean(total.mass)
)
# method 2
# we can also using functions defined by ourselves. this is extremly useful when you want #to do some complicated job for the subset of the data
# tv.f is a function to calculate the temporal variability of the toal biomass for a #given subplot
tv.f<-function(x){
#input x is the subset of your big dataset
#I first select the three columns including taxon, time, and biomass
x.selected<-select(x,taxon,time,biomass)
#then I make this three-column data to a matrix format with taxon
# as row and time as column
x.selected<-acast(x.selected,taxon~time,value.var='biomass')
# then i calculate the total biomass at each time point
total.mass<-colSums(x.selected)
temporal.variability<-sd(total.mass)/mean(total.mass)
setNames(temporal.variability, 'temporal.variability')
}
tv.total.mass.for.subplots.2<-ddply(
mydata,
~ site_code + block + plot + subplot,
tv.f)
#note, when you include your own functions in the ddply, you #need to drop the term #summarize
# check if the two approaches give same result
all.equal(tv.total.mass.for.subplots.1,tv.total.mass.for.subplots.2)
# return true
creatures
aj~animal+real
aj
aj <- ~ animal+real
aj
creatures$AJ <- paste(creatures$animal, creatures$real)
creatures
creatures$AJ <- paste(creatures$animal, creatures$real, sep = ":")
creatures
citation()
